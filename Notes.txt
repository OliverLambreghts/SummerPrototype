Todo:
- Player movement
- Level generation
- HUD
- Think about mechanics
- Lives
- Sound
- Camera
- Enemies
- Bosses
- Loot
- Map
- Collision with walls
- Collision with obstacles

- Let's start off with movement. Just make a simple movementcomponent which has functionality to move a gameobject in the level.

- We'll call this class the PlayerMovementComponent. It holds a Point2f member var. The player should move through this component. So if the player pushes an arrow key for example, this component's direction should change to the direction corresponding with that key. In the component's update method, the direction should first be checked and based on that the position should be modified. If no keys are pressed the position shouldn't be modified.

- The SpriteRenderComponent should also change the sprite of the player to a different row whenever a different key is pressed. When no keys are pressed, the player should be put in an idle texture of the last active row which is the first col of that row.

- To generate the world randomly, I will use the maze generation algorithm I used for my maze generation program. Each node in this maze represents a room. Each node has 4 node pointers. Through this algorithm each node receives a connection to one or more other nodes until a path is formed from the first node to the last. There is only 1 possible path from the first node to the last.

- World gameobject components:
	-> MazeComponent: Bevat alle rooms in een 2D array, een 	stack van Room pointers, een bool voor het genereren te 	stoppen en een pointer naar de huidige room.

- Vandaag wil ik eerst regelen dat de world generation gebeurt in de constructor van de maze component. Hier ga ik nog een aparte method voor aanmaken zodat ik de non-blocking versie ook nog kan callen als ik wil. Hierna wil ik een map toevoegen als je op M drukt. Deze toont de lay-out van de wereld en de kamers die je al bezocht hebt. Om de map uit te breiden moet je nieuwe kamers ontdekken.

--- ENEMIES W/ PROTOTYPE ---
5/07:
- Vandaag ga ik experimenteren met random enemies te spawnen in normal rooms. Elke normal room kan 1-4 spawners hebben. Elke spawner spawned 1x een enemy vanaf dat de player de room binnenkomt.

- Aan een Spawner geef je een GameObject mee van een bepaalde enemy. Deze GameObject MOET een bepaalde EnemyComponent hebben, anders kan de Spawner niet werken.

- De Clone method van een EnemyComponent returned een volledig GameObject waar alle nodige components al inzitten voor een complete enemy van dat type.

- De Spawn method van de Spawner called de Clone method van zijn interne prototype.

- Welke components heeft een enemy nodig?
	-> EnemyComponent (bevat data voor de andere comps)
	-> SpriteRenderComponent (rendered de enemy)
	-> EnemyMovementComponent (Zorgt voor AI movement)
	-> CollisionComponent (Checked voor collision tussen enemy 					en player en omgeving)
	-> HealthComponent (update de health v/d enemy)
	-> CombatComponent (handled de attacks v/d enemy tov de 							player)

- In het world GameObject een EnemyManagerComponent steken die voor elke room een random hoeveelheid spawners aanmaakt. Deze checked ook of de player een nieuwe room binnengaat, zo ja worden de spawners van die room geactiveerd. Deze comp houdt dus alle spawners bij voor elke room.

- In deze EnemyManagerComponent zit ook een pCurrentRoom. Hiervan wordt gechecked of deze nog currently active is via zijn bool. Als dit niet zo is, betekent dit dat de player van room veranderd is. In dat geval wordt gechecked of de spawners al gespawned hebben.

- Hierin mss een AddSpawner method toevoegen die een bepaalde spawner toevoegt aan een specifieke room?

- Of deze comp alleen laten werken met de current room? Telkens als er een nieuwe current room is en dus de player van room verandert, dan wordt de nieuwe room toegevoegd aan een map waarvan de keys room pointers zijn en de value is dan een vector van spawners?

- Als de player uit een room gaat, moeten de enemies die bij die room horen gedespawned worden. Dus als de player uit een room gaat, moeten die enemies op inactive gezet worden. Deze inactive flag bepaalt of de enemies gerendered en geupdate moeten worden.

- Het volgende dat ik wil doen is een object achteraan container van gameobjects zetten in de huidige scene zodat de map boven de rest gerendered wordt.

- De map moet eigenlijk achteraan de object container geplaatst worden telkens als de player een nieuwe room binnengaat.
----------------------------
7/07:
- Het volgende dat gedaan moet worden, is dat als de player een room binnengaat, dat de enemies binnen die room op de player aflopen obv hun speed.

- Hun bewegingsgedrag richting de player wordt bepaald door hun MovementComponent.

- Collision wordt bepaald in een aparte CollisionComponent dus dit niet in hun MovementComponent steken!

- De enemies hebben dus de positie van de player nodig als target om naartoe te bewegen.

- Het volgende is denk ik de player en de enemies elks een HealthComponent geven. Daarna ze een CombatComponent geven.

- Als een bepaalde attack key van de player ingedrukt wordt, dan voert de player een attack uit via zijn CombatComponent. Deze CombatComponent gaat de sprite van de player dan tijdelijk veranderen naar een attacking sprite.

- De CombatComponent moet ook checken of er enemies in de range van de player staan. Dus obv de huidige richting van de player moet er gechecked worden of er enemies voor de player staan in een bepaalde range. Als dit het geval is en de player attacked, dan moet de enemy die het dichtst bij de player staat aangevallen worden.

- De CombatComponent moet rechtstreeks kunnen communiceren met het eventuele wapen dat de player vastheeft zodat dit de attackdamage, speed en range aanpast.

- Er moet gechecked worden of het wapen dat de player vastheeft een ranged wapen is of een melee wapen is. Op basis hiervan moet een bijbehorende method gecalled worden die met dat type wapen werkt.
----------------------------