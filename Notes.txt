Todo:
- Player movement
- Level generation
- HUD
- Think about mechanics
- Lives
- Sound
- Camera
- Enemies
- Bosses
- Loot
- Map
- Collision with walls
- Collision with obstacles

- Let's start off with movement. Just make a simple movementcomponent which has functionality to move a gameobject in the level.

- We'll call this class the PlayerMovementComponent. It holds a Point2f member var. The player should move through this component. So if the player pushes an arrow key for example, this component's direction should change to the direction corresponding with that key. In the component's update method, the direction should first be checked and based on that the position should be modified. If no keys are pressed the position shouldn't be modified.

- The SpriteRenderComponent should also change the sprite of the player to a different row whenever a different key is pressed. When no keys are pressed, the player should be put in an idle texture of the last active row which is the first col of that row.

- To generate the world randomly, I will use the maze generation algorithm I used for my maze generation program. Each node in this maze represents a room. Each node has 4 node pointers. Through this algorithm each node receives a connection to one or more other nodes until a path is formed from the first node to the last. There is only 1 possible path from the first node to the last.

- World gameobject components:
	-> MazeComponent: Bevat alle rooms in een 2D array, een 	stack van Room pointers, een bool voor het genereren te 	stoppen en een pointer naar de huidige room.

- Vandaag wil ik eerst regelen dat de world generation gebeurt in de constructor van de maze component. Hier ga ik nog een aparte method voor aanmaken zodat ik de non-blocking versie ook nog kan callen als ik wil. Hierna wil ik een map toevoegen als je op M drukt. Deze toont de lay-out van de wereld en de kamers die je al bezocht hebt. Om de map uit te breiden moet je nieuwe kamers ontdekken.

--- ENEMIES W/ PROTOTYPE ---
5/07:
- Vandaag ga ik experimenteren met random enemies te spawnen in normal rooms. Elke normal room kan 1-4 spawners hebben. Elke spawner spawned 1x een enemy vanaf dat de player de room binnenkomt.

- Aan een Spawner geef je een GameObject mee van een bepaalde enemy. Deze GameObject MOET een bepaalde EnemyComponent hebben, anders kan de Spawner niet werken.

- De Clone method van een EnemyComponent returned een volledig GameObject waar alle nodige components al inzitten voor een complete enemy van dat type.

- De Spawn method van de Spawner called de Clone method van zijn interne prototype.

- Welke components heeft een enemy nodig?
	-> EnemyComponent (bevat data voor de andere comps)
	-> SpriteRenderComponent (rendered de enemy)
	-> EnemyMovementComponent (Zorgt voor AI movement)
	-> CollisionComponent (Checked voor collision tussen enemy 					en player en omgeving)
	-> HealthComponent (update de health v/d enemy)
	-> CombatComponent (handled de attacks v/d enemy tov de 							player)

- In het world GameObject een EnemyManagerComponent steken die voor elke room een random hoeveelheid spawners aanmaakt. Deze checked ook of de player een nieuwe room binnengaat, zo ja worden de spawners van die room geactiveerd. Deze comp houdt dus alle spawners bij voor elke room.

- In deze EnemyManagerComponent zit ook een pCurrentRoom. Hiervan wordt gechecked of deze nog currently active is via zijn bool. Als dit niet zo is, betekent dit dat de player van room veranderd is. In dat geval wordt gechecked of de spawners al gespawned hebben.

- Hierin mss een AddSpawner method toevoegen die een bepaalde spawner toevoegt aan een specifieke room?

- Of deze comp alleen laten werken met de current room? Telkens als er een nieuwe current room is en dus de player van room verandert, dan wordt de nieuwe room toegevoegd aan een map waarvan de keys room pointers zijn en de value is dan een vector van spawners?

- Als de player uit een room gaat, moeten de enemies die bij die room horen gedespawned worden. Dus als de player uit een room gaat, moeten die enemies op inactive gezet worden. Deze inactive flag bepaalt of de enemies gerendered en geupdate moeten worden.

- Het volgende dat ik wil doen is een object achteraan container van gameobjects zetten in de huidige scene zodat de map boven de rest gerendered wordt.

- De map moet eigenlijk achteraan de object container geplaatst worden telkens als de player een nieuwe room binnengaat.
----------------------------
7/07:
- Het volgende dat gedaan moet worden, is dat als de player een room binnengaat, dat de enemies binnen die room op de player aflopen obv hun speed.

- Hun bewegingsgedrag richting de player wordt bepaald door hun MovementComponent.

- Collision wordt bepaald in een aparte CollisionComponent dus dit niet in hun MovementComponent steken!

- De enemies hebben dus de positie van de player nodig als target om naartoe te bewegen.

- Het volgende is denk ik de player en de enemies elks een HealthComponent geven. Daarna ze een CombatComponent geven.

- Als een bepaalde attack key van de player ingedrukt wordt, dan voert de player een attack uit via zijn CombatComponent. Deze CombatComponent gaat de sprite van de player dan tijdelijk veranderen naar een attacking sprite.

- De CombatComponent moet ook checken of er enemies in de range van de player staan. Dus obv de huidige richting van de player moet er gechecked worden of er enemies voor de player staan in een bepaalde range. Als dit het geval is en de player attacked, dan moet de enemy die het dichtst bij de player staat aangevallen worden.

- De CombatComponent moet rechtstreeks kunnen communiceren met het eventuele wapen dat de player vastheeft zodat dit de attackdamage, speed en range aanpast.

- Er moet gechecked worden of het wapen dat de player vastheeft een ranged wapen is of een melee wapen is. Op basis hiervan moet een bijbehorende method gecalled worden die met dat type wapen werkt.
----------------------------
10/07:

- Het eerste dat ik wil doen vandaag is de enemy die het laagste staat in de wereld moet bovenaan gerendered worden enzovoort. Anders klopt de rendervolgorde niet in-game.

- De enemies in de huidige actieve room sorteren volgens hun y waarde en ze zo in de huidige scene een per een achteraan de obj vector zetten.

- Nu wil ik de combat tussen de enemies toevoegen. Om dit te doen moet ik de enemies en de player elks een eigen HealthComponent geven. Ook, ga ik de player een inventory moeten geven en ga ik weapons moeten toevoegen. Ik ga beginnen met de HealthComponent.

- De HealthComponent houdt de hoeveelheid health van het gameobject bij, heeft de functionaliteit om health af te trekken en toe te voegen. De player heeft een PlayerHealthComponent. Deze gaat het het spel resetten als de player volledig dood is. Enemies hebben een EnemyHealthComponent. Deze gaat de enemy uit de scene verwijderen als diens health op is.

- Denk nog maar eerst wat na over wat er moet gebeuren als de player sterft. Focus u eerst op het killen van enemies en de combat system en inventory en items.

- Je geeft de player een InventoryComponent waar alle items effectief in worden opgeslagen. Een apart HUD gameobject heeft een HUDRenderComponent die de inventory data uit het player gameobject haalt en dat gebruikt om de inventory te renderen als deel van de HUD.

- Als de player op spatie drukt wordt het huidig geselecteerde item geactiveerd. Als dat een wapen is, wordt dat wapen's execute method gecalled die de dichtstbijzijnde enemy gaat zoeken binnen een bepaalde radius en op die enemy een attack gaat uitvoeren op basis van de stats en eventuele ability van het wapen.

- We zullen beginnen met items. Stel uw item system op zodanig dat je op een simpele manier nieuwe items kan toevoegen. Je gaat heel veel randomized wapens willen die je makkelijk toevoegt. 

- We hebben een base Item class nodig. 

- Typed object gaat niet voor items want items zijn geen types en elk item heeft unieke stats en een eventuele unieke ability.

class WeaponQuality
{
public:
	WeaponQuality(std::string name, Color4f color, float 
		damageMltplr, float cooldownMltplr)
private:
	std::string m_Name;
	Color4f m_Color;
	float m_DamageMultiplier, m_CooldownMultiplier;
}

class MeleeKey final : public Item
{
public:
	MeleeKey(std::string name, int damage, float cooldown,
		BaseProc* proc, WeaponQuality& quality);

	virtual void OnUse() override;
private:
	std::string m_Name;
	int m_Damage;
	float m_Cooldown;
	BaseProc* m_pProc;
	WeaponQuality& m_WeaponQuality;
}

int main
{
	WeaponQuality epic{"Epic", Color4f{1.f, 0.f, 0.f, 1.f},
	1.01f, 0.9f};
	// Chance on hit: does dot fire dmg
	auto fireProc = new FireProc{};
	// Chance on hit: critical strike
	auto critProc = new CritProc{};
	MeleeKey keyOfFire{"Key of Fire", 10, 0.5f, fireProc,
	epic};
	MeleeKey keyOfMight{"Key of Might", 12, 0.9f, critProc,
	epic};
}

- Nu alles implementeren. Ik geef het world gameobject een ItemManagerComponent. Deze gaat in treasure rooms een item spawnen. Die checked eerst of de current room een treasure room is. Zo ja, dan maakt die een random item aan (meleekey, rangedkey, consumable) met een random naam en bijbehorende stats (deze haalt die uit de bijbehorende text file met namen voor items).

- Bv. als de huidige room een treasure room is:

SpawnRandomItem()
{
	ItemType type = static_cast<ItemType>(rand()% 3);
	std::ifstream file;

	switch(type)
	{
		case ItemType::MeleeKey:
		file.open("../ItemData/MeleeList.txt");
		std::string line{};
		std::vector<std::string> lines;
		while(!file.eof())
		{
			std::getline(file, line);
			lines.push_back(line);
		}

		std::random_shuffle(lines.begin(), lines.end());
		const auto weapon = lines.front();
		std::vector<std::string> weaponData;
		ParseData(weapon, weaponData);
		auto meleeKey = new MeleeKeyComponent{weaponData		[0],
		weaponData[1], weaponData[2], weaponData[3],
		weaponData[4]};
		m_Items[m_pCurrentRoom] = meleeKey->Clone();
	break;
		case ItemType::RangedKey:

	break;
		case ItemType::Consumable:

	break;
	}
}

- Welke components heeft een melee key nodig?
	-> SpriteRenderComponent
	-> MeleeKeyComponent
	-> ActivityComponent

- De Item generation moet pas gebeuren als de volledige maze gegenerate is.

TODO
- Enemy render bug fiksen.